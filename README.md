##依赖注入
在Spring容器启动时，容器会读取配置文件或注解，分析需要创建的Bean，创建Bean实例并将Bean注册到Bean工厂中。Bean工厂是Spring框架中的一个核心接口，它负责创建、配置和管理Bean实例。

在创建Bean实例时，Spring容器会根据Bean定义中的依赖关系来判断需要注入哪些依赖。当Spring容器发现某个Bean需要注入其他Bean时，它会先根据被注入Bean的类型在容器中查找相应的Bean实例。

然后，Spring容器会使用Java反射机制来将需要注入的依赖对象实例注入到目标对象的相应属性中。具体来说，Spring会先获取目标对象的Class对象，然后遍历目标对象的所有属性，判断每个属性是否需要注入依赖。如果需要注入依赖，Spring就会根据依赖类型查找相应的依赖实例，并通过反射机制将依赖实例设置到目标对象的相应属性中。

在注入依赖时，Spring还支持多种注入方式，包括构造函数注入、Setter方法注入和字段注入。其中，构造函数注入是最常用的注入方式，它通过构造函数来注入依赖，可以保证对象在创建时所有依赖都已经注入，从而提高代码的健壮性和可维护性。Setter方法注入和字段注入则是通过Setter方法和字段来注入依赖，它们的主要优点是灵活性高，可以在任何时候注入依赖。

当Spring容器需要创建一个对象时，它会首先查找该对象所依赖的其他对象，然后将这些依赖注入到该对象中。这个过程通常是通过BeanPostProcessor和AutowiredAnnotationBeanPostProcessor等后置处理器来实现的。

其中，BeanPostProcessor是Spring框架中一个重要的扩展点，它可以在Bean对象实例化、初始化和销毁等不同阶段进行扩展和定制。在实现依赖注入时，Spring会在Bean对象实例化之后，调用BeanPostProcessor中的postProcessBeforeInitialization方法和postProcessAfterInitialization方法来实现依赖注入。

具体来说，Spring会首先查找对象的构造函数、Setter方法和字段，然后根据这些信息来创建对象实例，并将所依赖的其他对象注入到对象中。在注入过程中，Spring会使用Java的反射机制来获取对象的属性和方法，并通过setter方法或字段来进行赋值操作。如果对象中的某个属性或方法使用了@Autowired或@Resource等注解，则Spring会使用Java的动态代理机制来创建代理对象，并将代理对象注入到对象中。

总的来说，依赖注入的底层原理是基于反射机制和Java的动态代理机制，通过BeanPostProcessor等后置处理器来实现对象之间的解耦和松耦合。这样可以让我们更加专注于业务逻辑的开发，同时也提高了代码的可读性和可维护性。

## 工作流

## 数据库三大范式
1:遵循系统需求，确保每列的原子性。
2:每张表中只能保存一种业务数据，不能保存与该表无关的数据。
3:禁止B属性依赖主键的情况下，B被非主键的A属性依赖。

## redis缓存穿透，击穿，雪崩
缓存穿透是指缓存中没有而且数据库中也没有的数据，缓存中没有会去数据库中查，在被多次请求的情况下造成的数据库压力过大。

一般使用身份验证、数据基本校验，或者在第一次没有查到就将该数据添加进缓存，设置一个空值。


缓存击穿是指缓存中没有，数据库中有的数据，高并发情况下请求缓存中查询不到，去数据库中查， 造成数据库压力激增。

出现这种情况可以对接口限流、熔断（停用相关接口）、降级（随机过滤掉并抛弃一些请求，对这些请求不进行处理，而是返回一些异常信息），添加锁，


雪崩是指内存中有大量数据到达过期时间，同时又有高并发的请求进来，导致数据库压力过大。

可以设置随机过期时间，分布式部署，或者是热点数据永不过期。

## redis分布式锁
redisson，常用于秒杀系统，分布式系统中保证不同系统中的证数据安全

一般的实现方式为搭建一个单独的锁服务器。同一时刻必须只能有一个线程获取到锁。

## 常用的设计模式
工厂：声明接口，具体规范在接口中声明，具体的实现由各自的实现类来实现，相互并不影响。

单例：创建一个全局的共享对象，方便资源的调用，缺点是多线程下不能保证数据的原子性。

## AOP底层如何实现的
JDK动态代理/CGLib代理

JDK动态代理：将需要Class加载进jvm---->创建类对象---->生成类加载器---->获取类对象内的所有方法---->实现切面功能。

CGLib:

## redis缓存穿透怎么解决 
穿透：身份验证，token验证，第一次没有请求到的值可以创建一个空对象放在缓存中。

击穿：限流(令牌桶，增加中间人，发放有效token，非有效token不处理)、熔断（关闭接口）、降级（对请求过滤，随机抛弃一些请求，返回错误请求之类或服务器繁忙请重试之类的消息）。

雪崩：设置随机的过期时间，热点数据永不过期。

## 介绍MySQL的索引
mysql的索引分两种数据结构，hash和btree，也分为innodb和myisam两种引擎，这两种都使用b+tree数据结构。

innodb采用的时聚簇索引，innodb的数据文件只有两个文件，一个表结构文件，一个数据文件，因为索引和数据文件放在一起，所以称为聚簇索引。查询的话只要找到索引就能立刻获取到对应的数据信息。

myisam采用的时非聚簇索引，myisam的数据文件有三个文件，一个表结构，一个数据文件，一个索引文件，因为索引和数据不是放在一起的所以成为非聚簇索引。查询需要现在索引表中找到索引获取到对应的地址，再去数据表中取数据，跨文件操作。

## spring如何加载配置
通过@EnableAutoConfiguration，@ComponentScan注解，在程序启动时，自动扫描启动类下的所有包，将所有符合条件的类都加载到spring的ioc容器中。

## SQL语句优化
数据量大的情况下可以使用between and分页

条件中尽量少使用!= 、 <> 、 like，因为会全表扫描

in或not in容易全表扫描，使用时需要注意

避免全表扫描

避免select *

避免查询条件中判断null

对常用的查询条件做聚合索引

## spring 事务

## 封装 继承 多态

封装：将类的内部细节隐藏

继承：子类继承父类，可以实现父类的行为特点，也可以覆盖父类的行为特点

多态：同一个行为有多种的实现方法。

## 重载和重写的区别

重载：一个方法有多个实现方式，可以有不同的参数，不同的返回值，但都是同一个方法名。

重写：子类可以实现父类的行为特点，也可以覆盖掉父类的行为特点。

## Spring Boot和Spring Cloud的区别是什么

Spring Cloud 微服务，或者称之为分布式服务，Spring Cloud是由spring boot实现而来，可以将多个系统模块拆分为独立的系统服务，并由注册中心统一管理。

spring boot一般作用在单点服务中，他的特点相比较mvc简化了繁琐的配置，还可以集合各种框架统一使用。

## 什么时候用Spring Boot，什么时候用Spring Cloud

在并发要求不高的情况下使用Spring Boot作为单点服务来提供，在并发要求高的情况下使用spring cloud，对重点系统模块进行多处部署，保证系统的一个高可用状态。

## Spring Boot和Spring Cloud都有什么缺点
spring boot只能作为一个单点服务来提供，无法对一个系统进行集群化的部署，只要系统挂了就需要人工去维护。

spring cloud的缺点是如果微服务过多，服务器的成本过高，即使有注册中心来管理，维护起来也比较繁琐。

## 索引过多，会影响性能吗？

会，mysql的索引基本都是b+tree数据结构，也可以选择hash数据结构。

在b+tree数据结构下，每新增一个索引都会对整个树的数据结构造成一次改动，在查询时会多扫描一遍叶子节点。

在hsah数据结构下，因为mysql会对hash表进行顺序排序，每一次对索引的改动都会改动这张hash表，而且hash表中的数据也是随着索引数量增加的，所以查询的时候会进行一些不必要的扫描。

## MyBatis和MyBatis Plus有什么区别

mybatis plus是mybatis的增强工具，可以提供基本的curdsql，可以预防sql注入，支持代码生成。

## Nacos主要做什么

注册中心，服务发现，消息中心，配置中心

## spring自动装配原理

主要是通过@EnableAutoConfiguration注解来实现的，一般这个这个注解不需要我们手动实现，他会在程序启动时，自动从程序启动类的根目录下开始遍历目录下所有文件，找到@configuration注解的class，或者是@bean注解的class，通过反射装载到IOC容器中，如果是使用spring mvc则是通过xml文件装配bean，spring boot只需要class上添加@bean注解。

## spring的ioc和aop是什么

spring的核心就是ioc和aop，ioc是控制反转，aop是面向切面编程，ioc控制反转就是说我们平时创建一个对象是手动new出来，自己管理的，而ioc是将对象交给spring框架来管理，他是通过DI注入来实现的，spring框架在启动时会加载所有bean信息，将他们放在一个map集合中，每一个bean都有自己的生命周期（生成实例对象-->填充属性-->初始化信息-->aop-->生成代理对象）。

aop概念比较抽象，用通俗的例子来讲，比如我们有一个add函数接口，我们需要记录这个函数的执行耗时，通常我们会用current time来记录一个开始时间和一个结束时间来计算，如果每一个接口都这样做，会产生大量的冗余代码，特别是日志记录，但用aop我们可以通过注解的方式来减少代码冗余，常用的就是@after，@before,@around

## linux常用命令

mkdir 创建文件夹

touch 创建文件

rm -rf 删除

su 切换用户

sudu 管理员权限

vi或vim 修改文件

cat 查看文件

yum install 安装包

yum remove 删除包

yum -y updage 更新包

yum -y upgrade 更新包但不更新软件和系统

## String、String Buffer和String Build的区别，怎么保证线程安全

String、String buffer和String Build都是通过char类型数组实现的，只不过String添加了final修饰，所以String变量定义了后不可变，如果对String变量进行**频繁**的修改、拼接等操作，会产生大量的GC回收，很占用系统的资源。

String Buffer和String Build调用同一父类append方法，采用相同的扩容机制，保证了性能开销。

String Buffer是线程安全的，String Build是非线程安全的。String Buffer在所有操作类的方法上添加了synchronized来保证线程安全。

所以String Buffer要比String Build慢一些，在不考虑线程安全的情况下，尽量使用String Build。

## 什么是锁

锁是一种机制，在并发编程中，多个线程对同一资源进行争夺，导致线程不安全，为了解决这个问题，引入了抽象的锁概念，来对资源进行锁定。

jvm中一个对象的对象头包含gc状态、对象布局、类型、同步状态、哈希标识基本信息。

锁就是改变对象的对象头中的同步状态。

参考：（http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html ） object header

## 什么是死锁

在多线程编程中，多个线程对同一个对象使用了多把锁，造成了线程互相等待，程序不往下走了，一般称为死锁。

## synchronized原理是什么

在对方法或者是变量使用synchronized，class文件在编译后的字节码中会生成monitorenter和monitorexit两个指令，这两个指令会调用jvm中使用C++实现的trylock方法，再由该方法调用汇编指令调用系统低层接口实现锁的抢占，中间还会涉及锁升级一系列操作。

jvm中每个对象都包含对象头，对齐数据，实例数据，对象的锁信息都包含在对象头的mark word中，其中包含无锁、偏向锁、轻量级锁、重量级锁的信息，synchronized就是修改mark word中锁的信息。

## synchronized怎么用的

可以修饰方法，也可以修饰代码块。

## ==和equals的区别

==如果是基本类型比较的是栈中的值，如果是引用类型比较的是对象地址。

equals通常都会被从重写，所以比较的是对象的值。

## 讲一下final

final可以修饰类、变量、方法

被final修饰的类不可以被继承。

被final修饰的变量不可以改变，在声明变量是就需要赋值，如果是基本类型的话在初始化后不可以被修改，是引用类型的话可以修改引用的值，但不能指向新的引用。

被final修饰的的方法不可以被重写，但可以重载。

## 接口和抽象类的区别

接口的目的是定义规范，抽象类的目的是抽取公共代码实现代码复用。

接口中只有abstract方法，抽象类中abstract方法或普通方法都可以有。

接口可以被实现多个，抽象类只能被继承一个。

接口跟他的实现类的关系是like a，抽象类跟他的继承类的关系是is a。

## List和Set的区别

List是有序的，添加的值可以重复，可以为空，取数据可以用迭代器取也可以用下标取

Set无序的，添加的值不可以重复，取数据只能用迭代器取。

## ArrayList和LinkedList的区别

ArrayList是基于动态数组实现的，使用ArrayList查询比较快，因为他在内从中是连续存储，我们随机访问的速度很快，但是插入数据会很慢，因为他要对数据进行移动。

LinkedList是基于链表实现的，他的查询比较慢，但是插入很快，因为他在内存中是分散存储的，每添加一个元素都会保存指向下一个元素的地址，访问的话需要遍历所有的元素。

## HashMap和HashTable的区别

HashMap和HashTable的底层都是通过数组+链表实现的，具体的是数组长度超过64链表长度超过8，这时候会转换为红黑树。

HashMap是非线程安全的，HashTable是线程安全的，他有synchronized方法修饰。

## ConcurrentHashMap

ConcurrentHashMap是通过synchronized+CAS+红黑树实现的，他的所有操作都是通过CAS实现，除非出现hash冲突会使用synchronized锁，所以他的锁粒度更细，效率更高，能保证线程安全的情况下性能更高。

## 索引的原理

MySql中有Hash索引和BTREE索引
hash索引是在创建索引时会生成一张hash表，将索引列的数据hash运算后存放在这张表里（顺序排序），下一次查找时根据条件hash运算到hash表中查找，可以很快的得到hash值对应的数据地址位置，不需要全表遍历。
BTREE索引则是用的b+树数据结构

## synchronized锁优化，锁粗化，锁消除

## 什么是自旋锁

自旋可以理解为一种轮询，线程会不断循环去尝试查看目标资源的锁有没有释放，如果释放了那么就获取，如果没有那么将进入下一轮循环。

## 什么是偏向锁

在无锁状态下，只有一个线程进来争夺锁资源，jvm将线程id写入对象头markword中，如果后续来争夺资源的锁id为同一个锁，那么这时候可以称之为偏向锁。

jvm在启动后，默认延迟4秒后启动偏向锁（可以设置jvm参数修改），后续所有新建对象的对象头中，锁状态默认为偏向锁（1 01）。

如果给锁状态为无锁的对象（0 01）添加synchronized关键字，对象会直接从无锁（0 01）升级为轻量级锁（1 00）。

## 什么是轻量级锁

在资源处于偏向锁状态下，出现了多个线程争夺锁资源的情况下，偏向锁将升级为轻量级锁。

## 什么是重量级锁

有多线程处于自旋状态，而且自旋个数超过cpu核数的一半或者是自旋次数超过10次，线程id进入等待队列，轻量级锁升级为重量级锁（1 10)

## synchronized和volatile的区别是什么

## 为什么要用volatile

volatile的特点就是当一个线程修改一个被volatile修饰的变量的值时，会被其他线程立刻感知到。

volatile只能保证在多线程情况下对共享变量读写数据具有原子性，其他情况下不能保证原子性。

## 说一说Java内存模型

## 说一说Java并发包

## failfast和failsafe区别

## 什么是copyOnWrite

## 什么是AQS

## 什么是CAS

在有多个线程对同一资源进行争夺的情况下，我们不想对这个资源进行锁定，而是通过其他方式来限制，同时只有一个线程能资源争夺成功，而其他修改失败的线程将会不断重试，直到修改成功。这种方式称之为cas。

## 什么是乐观锁

乐观锁相对悲观锁，每次获取资源不会对其上锁，在修改资源时会判断期间有没有其他线程修改了资源。乐观锁的一种实现方式就是cas。

## 什么是悲观锁

在一个线程获取资源时总会认为资源会被其他线程修改，所以每次获取资源都会上锁，这样的话，想要修改资源的线程就会被一直阻塞，直到获取到锁。

## 乐观锁和悲观锁是怎么实现的，区别是什么

## 什么是行级锁

## 什么是表级锁

## 什么是共享锁

## 什么是排他锁

## 什么是gap锁

## 什么是next key lock

## 数据库的隔离级别有哪些

## 说一说数据库的索引

## 什么是聚簇索引

## 什么是非聚簇索引

## 什么是最左前缀

## 索引如何实现的

## 什么是哈希索引

## 什么是B+树，如何实现的

## B+树里面的存储是怎么存的

## 为什么要用B+树

## 什么是回表

## 什么是分布式锁

## 分布式锁如何实现的

## 数据库，redis，zookeeper实现分布式锁的区别是什么，各自有什么优缺点

## 为什么要使用redis

redis可以做数据缓存、分布式锁、消息队列，还支持事务，持久化，集群方案。

## 什么是分布式缓存

一个服务端负责管理，多个客户端存储数据，根据一致性算法确定数据存储的节点。

## redis和memcache有什么区别

## zookeeper怎么实现分布式锁

## 什么是zookeeper

## 什么是cap

## 为什么cap不能同时存在

## 什么是base理论

## 分布式系统如何保证数据一致性

更新缓存、删除缓存

先更新数据库再删缓存

先更新缓存再删数据库

延迟双删

引入消息队列保证一致性

## 分布式数据一致性有哪些算法

## 什么是paxos算法

